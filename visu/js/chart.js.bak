function Chart(id) {
	var self = this;
	var chart = id;
	var c = chart[0].getContext('2d');

	var colors = new Array("#FF0000", "#0000FF", "#009600", "#FF7D00", "#FF00FF", "#7D4B00");

	var width ;
	var height;

	var size;
	var yMaxArr = new Array();
	var stepArr = new Array();

	var yGraphOffset = 10;
	var xOffset = 40;
	var yOffset = 20;

	var graphNames = new Array();

	var border = false;
	var xGrid = false;
	var yGrid = false;
	var points = false;

	var lineThickness = 1;

	this.init = function() {
		self.resize();
	}

	this.resize = function() {
		$(chart).attr("width", $(id).parent().width());

		width = $(chart).attr("width");
		height = $(chart).attr("height");

		c.strokeStyle = "#DDD";

		/**< draw border */
		if(border) {
			c.lineWidth = 3;
			c.strokeRect(xOffset, yGraphOffset, getGraphWidth(), getGraphHeight());
		}

		// c.strokeRect(0, 0, width, height);
	}

	this.draw = function(curve) {
		size = curve.data.length;
		// calculate the max value for each graph
		for(var i = 0; i < curve.yCount; i++) {
			yMaxArr.push(getMaxY(curve.data, i));
			stepArr.push(getStepWidth(i));
		}

		/**
		 * X-Achse
		 */
		c.lineWidth = 1;
		c.strokeStyle = "#DDD";
		c.textAlign = "center";
		c.textBaseline = "middle";
		for(var i in curve.data) {
			if(xGrid) {
				var xPixel = getXPixel(i);
				c.beginPath();
				c.moveTo(xPixel, getGraphHeight() + yGraphOffset);
				c.lineTo(xPixel, + yGraphOffset);
				c.stroke();
			}
		}

		/*
		 * Y-Achse Grid + Beschriftung
		 */
		c.lineWidth = 1;
		for(var y = 0; y < curve.yCount; y++) {
			// y-axis + y-grid
			for (var i = 0; i <= yMaxArr[y]; i += stepArr[y]) {
				var yPixel = getYPixel(i, y);
				if(yGrid) {
					// if zero line set lineWidth = 3
					if(i == 0) {
						c.lineWidth = 3;

						// draw graph names
						c.textBaseline = "bottom";
						c.strokeStyle = "#DDD";
						c.textAlign = "left";
						c.font = "16pt Sans";
						c.fillText(graphNames[y], xOffset + 10 , yPixel - 10);

					} else {
						c.lineWidth = 1;
					}
					c.textBaseline = "middle";
					c.strokeStyle = "#DDD";
					c.textAlign = "right";
					c.font = "8pt Sans";
					c.beginPath();
					c.moveTo(xOffset, yPixel);
					c.lineTo(getGraphWidth() + xOffset, yPixel);
					c.stroke();
				}

				// don't draw the last y-axis label = first y-axis label from next chart
				if(i < yMaxArr[y] || y == (curve.yCount - 1)) {
					c.fillText(i, xOffset / 2, yPixel);
				}
			}
		}

		/**
		 * Graph
		 */
		c.lineWidth = lineThickness;
		for(var iY = 0; iY < /*curve.yCount*/ 1; iY++) {
			c.strokeStyle = colors[iY];
			c.beginPath();
			for(var iData in curve.data) {
				var yPixel = getYPixel(curve.data[iData].y[iY], iY);
				// draw line
				c.lineTo(getXPixel(iData), yPixel);
				// draw points
				if(points) {
					c.arc(getXPixel(iData), yPixel, 4, 0, Math.PI * 2, true);
				}
			}
			c.stroke();
		}
	}

	/**
	 * set border visible
	 */
	this.setBorder = function(state) {
		border = state;
	}

	/**
	 * set points visible
	 */
	this.setPoints = function(state) {
		points = state;
	}

	/**
	 * set x grid visible
	 */
	this.setXGrid = function(state) {
		xGrid = state;
	}

	/**
	 * set y grid visible
	 */
	this.setYGrid = function(state) {
		yGrid = state;
	}

	/**
	 * set line width (graph)
	 */
	this.setLineWidth = function(width) {
		lineThickness = width;
	}

	/**
	 * set graph names
	 */
	this.setGraphNames = function(names) {
		graphNames = names;
	}

	/**
	 * real width of graph
	 */
	function getGraphWidth() {
		return (width - xOffset - xOffset / 2);
	}

	/**
	 * real height of graph
	 */
	function getGraphHeight() {
		return (height - yOffset - yGraphOffset);
	}

	function getXPixel(val) {
		return (getGraphWidth() / size * val) + ((width - xOffset) / size) / 2 + xOffset;
	}

	function getYPixel(val, index) {
		return (height - getGraphHeight() / yMaxArr.length / yMaxArr[index] * val - yOffset) - (index) * getGraphHeight() / yMaxArr.length;

		// return (height - getGraphHeight() / yMax * val) - yOffset;
	}

	function getMaxY(data, index) {
		var max = 15;
		for (var i = 0; i < data.length; i++) {
			if (data[i].y[index] > max) {
				max = data[i].y[index];
			}
		}

		max = parseInt(max);
		max += 10 - max % 10;

		return max;
	}

	function getStepWidth(index) {
		var step = 0;
		// var max = yMax;
		var max = yMaxArr[index];
		for (var i = 1; i < max; i++) {
			if (max % i == 0 && i > step) {
				step = i;
			}
		}

		return step / 2;
	}
}
